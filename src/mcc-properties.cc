// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mcc-properties.hh"

namespace mcc
{
  // formula
  // 

  const formula::boolean_formula_optional& formula::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  formula::boolean_formula_optional& formula::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void formula::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void formula::
  boolean_formula (const boolean_formula_optional& x)
  {
    this->boolean_formula_ = x;
  }

  void formula::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  const formula::integer_formula_optional& formula::
  integer_formula () const
  {
    return this->integer_formula_;
  }

  formula::integer_formula_optional& formula::
  integer_formula ()
  {
    return this->integer_formula_;
  }

  void formula::
  integer_formula (const integer_formula_type& x)
  {
    this->integer_formula_.set (x);
  }

  void formula::
  integer_formula (const integer_formula_optional& x)
  {
    this->integer_formula_ = x;
  }

  void formula::
  integer_formula (::std::auto_ptr< integer_formula_type > x)
  {
    this->integer_formula_.set (x);
  }


  // property_set
  // 

  const property_set::property_sequence& property_set::
  property () const
  {
    return this->property_;
  }

  property_set::property_sequence& property_set::
  property ()
  {
    return this->property_;
  }

  void property_set::
  property (const property_sequence& s)
  {
    this->property_ = s;
  }


  // property
  // 

  const property::id_type& property::
  id () const
  {
    return this->id_.get ();
  }

  property::id_type& property::
  id ()
  {
    return this->id_.get ();
  }

  void property::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void property::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  ::std::auto_ptr< property::id_type > property::
  detach_id ()
  {
    return this->id_.detach ();
  }

  const property::description_type& property::
  description () const
  {
    return this->description_.get ();
  }

  property::description_type& property::
  description ()
  {
    return this->description_.get ();
  }

  void property::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void property::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  ::std::auto_ptr< property::description_type > property::
  detach_description ()
  {
    return this->description_.detach ();
  }

  const property::tags_type& property::
  tags () const
  {
    return this->tags_.get ();
  }

  property::tags_type& property::
  tags ()
  {
    return this->tags_.get ();
  }

  void property::
  tags (const tags_type& x)
  {
    this->tags_.set (x);
  }

  void property::
  tags (::std::auto_ptr< tags_type > x)
  {
    this->tags_.set (x);
  }

  ::std::auto_ptr< property::tags_type > property::
  detach_tags ()
  {
    return this->tags_.detach ();
  }

  const property::expected_result_optional& property::
  expected_result () const
  {
    return this->expected_result_;
  }

  property::expected_result_optional& property::
  expected_result ()
  {
    return this->expected_result_;
  }

  void property::
  expected_result (const expected_result_type& x)
  {
    this->expected_result_.set (x);
  }

  void property::
  expected_result (const expected_result_optional& x)
  {
    this->expected_result_ = x;
  }

  void property::
  expected_result (::std::auto_ptr< expected_result_type > x)
  {
    this->expected_result_.set (x);
  }

  const property::formula_type& property::
  formula () const
  {
    return this->formula_.get ();
  }

  property::formula_type& property::
  formula ()
  {
    return this->formula_.get ();
  }

  void property::
  formula (const formula_type& x)
  {
    this->formula_.set (x);
  }

  void property::
  formula (::std::auto_ptr< formula_type > x)
  {
    this->formula_.set (x);
  }

  ::std::auto_ptr< property::formula_type > property::
  detach_formula ()
  {
    return this->formula_.detach ();
  }


  // tags
  // 

  const tags::is_structural_type& tags::
  is_structural () const
  {
    return this->is_structural_.get ();
  }

  tags::is_structural_type& tags::
  is_structural ()
  {
    return this->is_structural_.get ();
  }

  void tags::
  is_structural (const is_structural_type& x)
  {
    this->is_structural_.set (x);
  }

  const tags::is_reachability_type& tags::
  is_reachability () const
  {
    return this->is_reachability_.get ();
  }

  tags::is_reachability_type& tags::
  is_reachability ()
  {
    return this->is_reachability_.get ();
  }

  void tags::
  is_reachability (const is_reachability_type& x)
  {
    this->is_reachability_.set (x);
  }

  const tags::is_ctl_type& tags::
  is_ctl () const
  {
    return this->is_ctl_.get ();
  }

  tags::is_ctl_type& tags::
  is_ctl ()
  {
    return this->is_ctl_.get ();
  }

  void tags::
  is_ctl (const is_ctl_type& x)
  {
    this->is_ctl_.set (x);
  }

  const tags::is_ltl_type& tags::
  is_ltl () const
  {
    return this->is_ltl_.get ();
  }

  tags::is_ltl_type& tags::
  is_ltl ()
  {
    return this->is_ltl_.get ();
  }

  void tags::
  is_ltl (const is_ltl_type& x)
  {
    this->is_ltl_.set (x);
  }


  // expected_result
  // 

  const expected_result::value_type& expected_result::
  value () const
  {
    return this->value_.get ();
  }

  expected_result::value_type& expected_result::
  value ()
  {
    return this->value_.get ();
  }

  void expected_result::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void expected_result::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }

  ::std::auto_ptr< expected_result::value_type > expected_result::
  detach_value ()
  {
    return this->value_.detach ();
  }

  const expected_result::explanation_type& expected_result::
  explanation () const
  {
    return this->explanation_.get ();
  }

  expected_result::explanation_type& expected_result::
  explanation ()
  {
    return this->explanation_.get ();
  }

  void expected_result::
  explanation (const explanation_type& x)
  {
    this->explanation_.set (x);
  }

  void expected_result::
  explanation (::std::auto_ptr< explanation_type > x)
  {
    this->explanation_.set (x);
  }

  ::std::auto_ptr< expected_result::explanation_type > expected_result::
  detach_explanation ()
  {
    return this->explanation_.detach ();
  }


  // value
  //

  value::
  value ()
  : ::xml_schema::string ()
  {
  }

  value::
  value (const char* s)
  : ::xml_schema::string (s)
  {
  }

  value::
  value (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  value::
  value (const value& o,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // invariant
  // 

  const invariant::boolean_formula_type& invariant::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  invariant::boolean_formula_type& invariant::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void invariant::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void invariant::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< invariant::boolean_formula_type > invariant::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // impossibility
  // 

  const impossibility::boolean_formula_type& impossibility::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  impossibility::boolean_formula_type& impossibility::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void impossibility::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void impossibility::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< impossibility::boolean_formula_type > impossibility::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // possibility
  // 

  const possibility::boolean_formula_type& possibility::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  possibility::boolean_formula_type& possibility::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void possibility::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void possibility::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< possibility::boolean_formula_type > possibility::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // all_paths
  // 

  const all_paths::boolean_formula_type& all_paths::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  all_paths::boolean_formula_type& all_paths::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void all_paths::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void all_paths::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< all_paths::boolean_formula_type > all_paths::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // exists_path
  // 

  const exists_path::boolean_formula_type& exists_path::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  exists_path::boolean_formula_type& exists_path::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void exists_path::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void exists_path::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< exists_path::boolean_formula_type > exists_path::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // next
  // 

  const next::boolean_formula_sequence& next::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  next::boolean_formula_sequence& next::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void next::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }

  const next::if_no_successor_sequence& next::
  if_no_successor () const
  {
    return this->if_no_successor_;
  }

  next::if_no_successor_sequence& next::
  if_no_successor ()
  {
    return this->if_no_successor_;
  }

  void next::
  if_no_successor (const if_no_successor_sequence& s)
  {
    this->if_no_successor_ = s;
  }

  const next::steps_sequence& next::
  steps () const
  {
    return this->steps_;
  }

  next::steps_sequence& next::
  steps ()
  {
    return this->steps_;
  }

  void next::
  steps (const steps_sequence& s)
  {
    this->steps_ = s;
  }


  // globally
  // 

  const globally::boolean_formula_type& globally::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  globally::boolean_formula_type& globally::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void globally::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void globally::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< globally::boolean_formula_type > globally::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // finally
  // 

  const finally::boolean_formula_type& finally::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  finally::boolean_formula_type& finally::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void finally::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void finally::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< finally::boolean_formula_type > finally::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // until
  // 

  const until::before_type& until::
  before () const
  {
    return this->before_.get ();
  }

  until::before_type& until::
  before ()
  {
    return this->before_.get ();
  }

  void until::
  before (const before_type& x)
  {
    this->before_.set (x);
  }

  void until::
  before (::std::auto_ptr< before_type > x)
  {
    this->before_.set (x);
  }

  ::std::auto_ptr< until::before_type > until::
  detach_before ()
  {
    return this->before_.detach ();
  }

  const until::reach_type& until::
  reach () const
  {
    return this->reach_.get ();
  }

  until::reach_type& until::
  reach ()
  {
    return this->reach_.get ();
  }

  void until::
  reach (const reach_type& x)
  {
    this->reach_.set (x);
  }

  void until::
  reach (::std::auto_ptr< reach_type > x)
  {
    this->reach_.set (x);
  }

  ::std::auto_ptr< until::reach_type > until::
  detach_reach ()
  {
    return this->reach_.detach ();
  }

  const until::strength_type& until::
  strength () const
  {
    return this->strength_.get ();
  }

  until::strength_type& until::
  strength ()
  {
    return this->strength_.get ();
  }

  void until::
  strength (const strength_type& x)
  {
    this->strength_.set (x);
  }

  void until::
  strength (::std::auto_ptr< strength_type > x)
  {
    this->strength_.set (x);
  }

  ::std::auto_ptr< until::strength_type > until::
  detach_strength ()
  {
    return this->strength_.detach ();
  }


  // before
  // 

  const before::boolean_formula_type& before::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  before::boolean_formula_type& before::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void before::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void before::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< before::boolean_formula_type > before::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // reach
  // 

  const reach::boolean_formula_type& reach::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  reach::boolean_formula_type& reach::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void reach::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void reach::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< reach::boolean_formula_type > reach::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // strength
  // 

  strength::
  strength ()
  : ::xml_schema::token ()
  {
  }

  strength::
  strength (value v)
  : ::xml_schema::token (_xsd_strength_literals_[v])
  {
  }

  strength::
  strength (const char* v)
  : ::xml_schema::token (v)
  {
  }

  strength::
  strength (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  strength::
  strength (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  strength::
  strength (const strength& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  strength& strength::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_strength_literals_[v]);

    return *this;
  }


  // deadlock
  // 


  // is_live
  // 

  const is_live::transition_sequence& is_live::
  transition () const
  {
    return this->transition_;
  }

  is_live::transition_sequence& is_live::
  transition ()
  {
    return this->transition_;
  }

  void is_live::
  transition (const transition_sequence& s)
  {
    this->transition_ = s;
  }

  const is_live::level_sequence& is_live::
  level () const
  {
    return this->level_;
  }

  is_live::level_sequence& is_live::
  level ()
  {
    return this->level_;
  }

  void is_live::
  level (const level_sequence& s)
  {
    this->level_ = s;
  }


  // level
  // 

  level::
  level ()
  : ::xml_schema::token ()
  {
  }

  level::
  level (value v)
  : ::xml_schema::token (_xsd_level_literals_[v])
  {
  }

  level::
  level (const char* v)
  : ::xml_schema::token (v)
  {
  }

  level::
  level (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  level::
  level (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  level::
  level (const level& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  level& level::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_level_literals_[v]);

    return *this;
  }


  // is_fireable
  // 

  const is_fireable::transition_sequence& is_fireable::
  transition () const
  {
    return this->transition_;
  }

  is_fireable::transition_sequence& is_fireable::
  transition ()
  {
    return this->transition_;
  }

  void is_fireable::
  transition (const transition_sequence& s)
  {
    this->transition_ = s;
  }


  // true_
  // 


  // false_
  // 


  // negation
  // 

  const negation::boolean_formula_type& negation::
  boolean_formula () const
  {
    return this->boolean_formula_.get ();
  }

  negation::boolean_formula_type& negation::
  boolean_formula ()
  {
    return this->boolean_formula_.get ();
  }

  void negation::
  boolean_formula (const boolean_formula_type& x)
  {
    this->boolean_formula_.set (x);
  }

  void negation::
  boolean_formula (::std::auto_ptr< boolean_formula_type > x)
  {
    this->boolean_formula_.set (x);
  }

  ::std::auto_ptr< negation::boolean_formula_type > negation::
  detach_boolean_formula ()
  {
    return this->boolean_formula_.detach ();
  }


  // conjunction
  // 

  const conjunction::boolean_formula_sequence& conjunction::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  conjunction::boolean_formula_sequence& conjunction::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void conjunction::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }


  // disjunction
  // 

  const disjunction::boolean_formula_sequence& disjunction::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  disjunction::boolean_formula_sequence& disjunction::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void disjunction::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }


  // exclusive_disjunction
  // 

  const exclusive_disjunction::boolean_formula_sequence& exclusive_disjunction::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  exclusive_disjunction::boolean_formula_sequence& exclusive_disjunction::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void exclusive_disjunction::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }


  // implication
  // 

  const implication::boolean_formula_sequence& implication::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  implication::boolean_formula_sequence& implication::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void implication::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }


  // equivalence
  // 

  const equivalence::boolean_formula_sequence& equivalence::
  boolean_formula () const
  {
    return this->boolean_formula_;
  }

  equivalence::boolean_formula_sequence& equivalence::
  boolean_formula ()
  {
    return this->boolean_formula_;
  }

  void equivalence::
  boolean_formula (const boolean_formula_sequence& s)
  {
    this->boolean_formula_ = s;
  }


  // integer_eq
  // 

  const integer_eq::integer_expression_sequence& integer_eq::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_eq::integer_expression_sequence& integer_eq::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_eq::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_ne
  // 

  const integer_ne::integer_expression_sequence& integer_ne::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_ne::integer_expression_sequence& integer_ne::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_ne::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_lt
  // 

  const integer_lt::integer_expression_sequence& integer_lt::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_lt::integer_expression_sequence& integer_lt::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_lt::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_le
  // 

  const integer_le::integer_expression_sequence& integer_le::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_le::integer_expression_sequence& integer_le::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_le::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_gt
  // 

  const integer_gt::integer_expression_sequence& integer_gt::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_gt::integer_expression_sequence& integer_gt::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_gt::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_ge
  // 

  const integer_ge::integer_expression_sequence& integer_ge::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_ge::integer_expression_sequence& integer_ge::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_ge::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_sum
  // 

  const integer_sum::integer_expression_sequence& integer_sum::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_sum::integer_expression_sequence& integer_sum::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_sum::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_product
  // 

  const integer_product::integer_expression_sequence& integer_product::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_product::integer_expression_sequence& integer_product::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_product::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_difference
  // 

  const integer_difference::integer_expression_sequence& integer_difference::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_difference::integer_expression_sequence& integer_difference::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_difference::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // integer_division
  // 

  const integer_division::integer_expression_sequence& integer_division::
  integer_expression () const
  {
    return this->integer_expression_;
  }

  integer_division::integer_expression_sequence& integer_division::
  integer_expression ()
  {
    return this->integer_expression_;
  }

  void integer_division::
  integer_expression (const integer_expression_sequence& s)
  {
    this->integer_expression_ = s;
  }


  // place_bound
  // 

  const place_bound::place_sequence& place_bound::
  place () const
  {
    return this->place_;
  }

  place_bound::place_sequence& place_bound::
  place ()
  {
    return this->place_;
  }

  void place_bound::
  place (const place_sequence& s)
  {
    this->place_ = s;
  }


  // tokens_count
  // 

  const tokens_count::place_sequence& tokens_count::
  place () const
  {
    return this->place_;
  }

  tokens_count::place_sequence& tokens_count::
  place ()
  {
    return this->place_;
  }

  void tokens_count::
  place (const place_sequence& s)
  {
    this->place_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

#include <xsd/cxx/tree/comparison-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;

  static
  const ::xsd::cxx::tree::comparison_plate< 0, char >
  comparison_plate_init;
}

namespace mcc
{
  // formula
  //

  formula::
  formula ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this),
    integer_formula_ (::xml_schema::flags (), this)
  {
  }

  formula::
  formula (const formula& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this),
    integer_formula_ (x.integer_formula_, f, this)
  {
  }

  formula::
  formula (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this),
    integer_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void formula::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->boolean_formula_)
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      // integer-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->integer_formula_)
          {
            ::std::auto_ptr< integer_formula_type > r (
              dynamic_cast< integer_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->integer_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  formula* formula::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formula (*this, f, c);
  }

  formula::
  ~formula ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, formula >
  _xsd_formula_type_factory_init (
    "formula",
    "http://mcc.lip6.fr/");

  static
  const ::xsd::cxx::tree::comparison_initializer< 0, char, formula >
  _xsd_formula_comparison_init;

  bool
  operator== (const formula& x, const formula& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      formula::boolean_formula_optional a (x.boolean_formula ()), b (y.boolean_formula ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      formula::integer_formula_optional a (x.integer_formula ()), b (y.integer_formula ());

      if (!a || !b)
      {
        if (a.present () != b.present ())
          return false;
      }
      else
      {
        if (!cm.compare (*a, *b))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const formula& x, const formula& y)
  {
    return !(x == y);
  }

  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::invariant >
  _xsd_invariant__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "invariant",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::impossibility >
  _xsd_impossibility__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "impossibility",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::possibility >
  _xsd_possibility__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "possibility",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::all_paths >
  _xsd_all_paths__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "all-paths",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::exists_path >
  _xsd_exists_path__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "exists-path",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::next >
  _xsd_next__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "next",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::globally >
  _xsd_globally__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "globally",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::finally >
  _xsd_finally__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "finally",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::until >
  _xsd_until__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "until",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::deadlock >
  _xsd_deadlock__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "deadlock",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::is_live >
  _xsd_is_live__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "is-live",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::is_fireable >
  _xsd_is_fireable__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "is-fireable",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::true_ >
  _xsd_true___element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "true",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::false_ >
  _xsd_false___element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "false",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::negation >
  _xsd_negation__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "negation",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::conjunction >
  _xsd_conjunction__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "conjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::disjunction >
  _xsd_disjunction__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "disjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::exclusive_disjunction >
  _xsd_exclusive_disjunction__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "exclusive-disjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::implication >
  _xsd_implication__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "implication",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::equivalence >
  _xsd_equivalence__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "equivalence",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_eq >
  _xsd_integer_eq__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-eq",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_ne >
  _xsd_integer_ne__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-ne",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_lt >
  _xsd_integer_lt__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-lt",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_le >
  _xsd_integer_le__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-le",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_gt >
  _xsd_integer_gt__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-gt",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_ge >
  _xsd_integer_ge__element_factory_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-ge",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xml_schema::type >
  _xsd_integer_expression_element_factory_init (
    "integer-formula",
    "http://mcc.lip6.fr/",
    "integer-expression",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xml_schema::integer >
  _xsd_integer_constant_element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-constant",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_sum >
  _xsd_integer_sum__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-sum",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_product >
  _xsd_integer_product__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-product",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_difference >
  _xsd_integer_difference__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-difference",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::integer_division >
  _xsd_integer_division__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-division",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::place_bound >
  _xsd_place_bound__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "place-bound",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::mcc::tokens_count >
  _xsd_tokens_count__element_factory_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "tokens-count",
    "http://mcc.lip6.fr/");


  // property_set
  //

  property_set::
  property_set ()
  : ::xml_schema::type (),
    property_ (::xml_schema::flags (), this)
  {
  }

  property_set::
  property_set (const property_set& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    property_ (x.property_, f, this)
  {
  }

  property_set::
  property_set (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    property_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void property_set::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // property
      //
      if (n.name () == "property" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< property_type > r (
          property_traits::create (i, f, this));

        this->property_.push_back (r);
        continue;
      }

      break;
    }
  }

  property_set* property_set::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class property_set (*this, f, c);
  }

  property_set::
  ~property_set ()
  {
  }

  bool
  operator== (const property_set& x, const property_set& y)
  {
    if (!(x.property () == y.property ()))
      return false;

    return true;
  }

  bool
  operator!= (const property_set& x, const property_set& y)
  {
    return !(x == y);
  }

  // property
  //

  property::
  property ()
  : ::xml_schema::type (),
    id_ (::xml_schema::flags (), this),
    description_ (::xml_schema::flags (), this),
    tags_ (::xml_schema::flags (), this),
    expected_result_ (::xml_schema::flags (), this),
    formula_ (::xml_schema::flags (), this)
  {
  }

  property::
  property (const id_type& id,
            const description_type& description,
            const tags_type& tags,
            const formula_type& formula)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    tags_ (tags, ::xml_schema::flags (), this),
    expected_result_ (::xml_schema::flags (), this),
    formula_ (formula, ::xml_schema::flags (), this)
  {
  }

  property::
  property (const id_type& id,
            const description_type& description,
            ::std::auto_ptr< tags_type >& tags,
            ::std::auto_ptr< formula_type >& formula)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    tags_ (tags, ::xml_schema::flags (), this),
    expected_result_ (::xml_schema::flags (), this),
    formula_ (formula, ::xml_schema::flags (), this)
  {
  }

  property::
  property (::std::auto_ptr< id_type >& id,
            ::std::auto_ptr< description_type >& description,
            ::std::auto_ptr< tags_type >& tags,
            ::std::auto_ptr< formula_type >& formula)
  : ::xml_schema::type (),
    id_ (id, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    tags_ (tags, ::xml_schema::flags (), this),
    expected_result_ (::xml_schema::flags (), this),
    formula_ (formula, ::xml_schema::flags (), this)
  {
  }

  property::
  property (const property& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    description_ (x.description_, f, this),
    tags_ (x.tags_, f, this),
    expected_result_ (x.expected_result_, f, this),
    formula_ (x.formula_, f, this)
  {
  }

  property::
  property (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (f, this),
    description_ (f, this),
    tags_ (f, this),
    expected_result_ (f, this),
    formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void property::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // id
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "id",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< id_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!id_.present ())
          {
            ::std::auto_ptr< id_type > r (
              dynamic_cast< id_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->id_.set (r);
            continue;
          }
        }
      }

      // description
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "description",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< description_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!description_.present ())
          {
            ::std::auto_ptr< description_type > r (
              dynamic_cast< description_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->description_.set (r);
            continue;
          }
        }
      }

      // tags
      //
      if (n.name () == "tags" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< tags_type > r (
          tags_traits::create (i, f, this));

        if (!tags_.present ())
        {
          this->tags_.set (r);
          continue;
        }
      }

      // expected-result
      //
      if (n.name () == "expected-result" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< expected_result_type > r (
          expected_result_traits::create (i, f, this));

        if (!this->expected_result_)
        {
          this->expected_result_.set (r);
          continue;
        }
      }

      // formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!formula_.present ())
          {
            ::std::auto_ptr< formula_type > r (
              dynamic_cast< formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "id",
        "http://mcc.lip6.fr/");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://mcc.lip6.fr/");
    }

    if (!tags_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tags",
        "http://mcc.lip6.fr/");
    }

    if (!formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "formula",
        "http://mcc.lip6.fr/");
    }
  }

  property* property::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class property (*this, f, c);
  }

  property::
  ~property ()
  {
  }

  bool
  operator== (const property& x, const property& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.id (), y.id ()))
        return false;
    }

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.description (), y.description ()))
        return false;
    }

    if (!(x.tags () == y.tags ()))
      return false;

    if (!(x.expected_result () == y.expected_result ()))
      return false;

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.formula (), y.formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const property& x, const property& y)
  {
    return !(x == y);
  }

  // tags
  //

  tags::
  tags ()
  : ::xml_schema::type (),
    is_structural_ (::xml_schema::flags (), this),
    is_reachability_ (::xml_schema::flags (), this),
    is_ctl_ (::xml_schema::flags (), this),
    is_ltl_ (::xml_schema::flags (), this)
  {
  }

  tags::
  tags (const is_structural_type& is_structural,
        const is_reachability_type& is_reachability,
        const is_ctl_type& is_ctl,
        const is_ltl_type& is_ltl)
  : ::xml_schema::type (),
    is_structural_ (is_structural, ::xml_schema::flags (), this),
    is_reachability_ (is_reachability, ::xml_schema::flags (), this),
    is_ctl_ (is_ctl, ::xml_schema::flags (), this),
    is_ltl_ (is_ltl, ::xml_schema::flags (), this)
  {
  }

  tags::
  tags (const tags& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    is_structural_ (x.is_structural_, f, this),
    is_reachability_ (x.is_reachability_, f, this),
    is_ctl_ (x.is_ctl_, f, this),
    is_ltl_ (x.is_ltl_, f, this)
  {
  }

  tags::
  tags (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    is_structural_ (f, this),
    is_reachability_ (f, this),
    is_ctl_ (f, this),
    is_ltl_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void tags::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // is-structural
      //
      if (n.name () == "is-structural" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        if (!is_structural_.present ())
        {
          this->is_structural_.set (is_structural_traits::create (i, f, this));
          continue;
        }
      }

      // is-reachability
      //
      if (n.name () == "is-reachability" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        if (!is_reachability_.present ())
        {
          this->is_reachability_.set (is_reachability_traits::create (i, f, this));
          continue;
        }
      }

      // is-ctl
      //
      if (n.name () == "is-ctl" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        if (!is_ctl_.present ())
        {
          this->is_ctl_.set (is_ctl_traits::create (i, f, this));
          continue;
        }
      }

      // is-ltl
      //
      if (n.name () == "is-ltl" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        if (!is_ltl_.present ())
        {
          this->is_ltl_.set (is_ltl_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!is_structural_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is-structural",
        "http://mcc.lip6.fr/");
    }

    if (!is_reachability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is-reachability",
        "http://mcc.lip6.fr/");
    }

    if (!is_ctl_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is-ctl",
        "http://mcc.lip6.fr/");
    }

    if (!is_ltl_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is-ltl",
        "http://mcc.lip6.fr/");
    }
  }

  tags* tags::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tags (*this, f, c);
  }

  tags::
  ~tags ()
  {
  }

  bool
  operator== (const tags& x, const tags& y)
  {
    if (!(x.is_structural () == y.is_structural ()))
      return false;

    if (!(x.is_reachability () == y.is_reachability ()))
      return false;

    if (!(x.is_ctl () == y.is_ctl ()))
      return false;

    if (!(x.is_ltl () == y.is_ltl ()))
      return false;

    return true;
  }

  bool
  operator!= (const tags& x, const tags& y)
  {
    return !(x == y);
  }

  // expected_result
  //

  expected_result::
  expected_result ()
  : ::xml_schema::type (),
    value_ (::xml_schema::flags (), this),
    explanation_ (::xml_schema::flags (), this)
  {
  }

  expected_result::
  expected_result (const value_type& value,
                   const explanation_type& explanation)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    explanation_ (explanation, ::xml_schema::flags (), this)
  {
  }

  expected_result::
  expected_result (::std::auto_ptr< value_type >& value,
                   ::std::auto_ptr< explanation_type >& explanation)
  : ::xml_schema::type (),
    value_ (value, ::xml_schema::flags (), this),
    explanation_ (explanation, ::xml_schema::flags (), this)
  {
  }

  expected_result::
  expected_result (const expected_result& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    explanation_ (x.explanation_, f, this)
  {
  }

  expected_result::
  expected_result (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (f, this),
    explanation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void expected_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      // explanation
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "explanation",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< explanation_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!explanation_.present ())
          {
            ::std::auto_ptr< explanation_type > r (
              dynamic_cast< explanation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->explanation_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://mcc.lip6.fr/");
    }

    if (!explanation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "explanation",
        "http://mcc.lip6.fr/");
    }
  }

  expected_result* expected_result::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class expected_result (*this, f, c);
  }

  expected_result::
  ~expected_result ()
  {
  }

  bool
  operator== (const expected_result& x, const expected_result& y)
  {
    if (!(x.value () == y.value ()))
      return false;

    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.explanation (), y.explanation ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const expected_result& x, const expected_result& y)
  {
    return !(x == y);
  }

  // value
  //

  value::
  value (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  value::
  value (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  value::
  value (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  value* value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value (*this, f, c);
  }

  // invariant
  //

  invariant::
  invariant ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  invariant::
  invariant (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  invariant::
  invariant (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  invariant::
  invariant (const invariant& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  invariant::
  invariant (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void invariant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  invariant* invariant::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class invariant (*this, f, c);
  }

  invariant::
  ~invariant ()
  {
  }

  bool
  operator== (const invariant& x, const invariant& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const invariant& x, const invariant& y)
  {
    return !(x == y);
  }

  // impossibility
  //

  impossibility::
  impossibility ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  impossibility::
  impossibility (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  impossibility::
  impossibility (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  impossibility::
  impossibility (const impossibility& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  impossibility::
  impossibility (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void impossibility::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  impossibility* impossibility::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class impossibility (*this, f, c);
  }

  impossibility::
  ~impossibility ()
  {
  }

  bool
  operator== (const impossibility& x, const impossibility& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const impossibility& x, const impossibility& y)
  {
    return !(x == y);
  }

  // possibility
  //

  possibility::
  possibility ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  possibility::
  possibility (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  possibility::
  possibility (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  possibility::
  possibility (const possibility& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  possibility::
  possibility (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void possibility::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  possibility* possibility::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class possibility (*this, f, c);
  }

  possibility::
  ~possibility ()
  {
  }

  bool
  operator== (const possibility& x, const possibility& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const possibility& x, const possibility& y)
  {
    return !(x == y);
  }

  // all_paths
  //

  all_paths::
  all_paths ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  all_paths::
  all_paths (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  all_paths::
  all_paths (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  all_paths::
  all_paths (const all_paths& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  all_paths::
  all_paths (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void all_paths::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  all_paths* all_paths::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class all_paths (*this, f, c);
  }

  all_paths::
  ~all_paths ()
  {
  }

  bool
  operator== (const all_paths& x, const all_paths& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const all_paths& x, const all_paths& y)
  {
    return !(x == y);
  }

  // exists_path
  //

  exists_path::
  exists_path ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  exists_path::
  exists_path (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  exists_path::
  exists_path (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  exists_path::
  exists_path (const exists_path& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  exists_path::
  exists_path (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void exists_path::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  exists_path* exists_path::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class exists_path (*this, f, c);
  }

  exists_path::
  ~exists_path ()
  {
  }

  bool
  operator== (const exists_path& x, const exists_path& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const exists_path& x, const exists_path& y)
  {
    return !(x == y);
  }

  // next
  //

  next::
  next ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this),
    if_no_successor_ (::xml_schema::flags (), this),
    steps_ (::xml_schema::flags (), this)
  {
  }

  next::
  next (const next& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this),
    if_no_successor_ (x.if_no_successor_, f, this),
    steps_ (x.steps_, f, this)
  {
  }

  next::
  next (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this),
    if_no_successor_ (f, this),
    steps_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void next::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      // if-no-successor
      //
      if (n.name () == "if-no-successor" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        this->if_no_successor_.push_back (if_no_successor_traits::create (i, f, this));
        continue;
      }

      // steps
      //
      if (n.name () == "steps" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        this->steps_.push_back (steps_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  next* next::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class next (*this, f, c);
  }

  next::
  ~next ()
  {
  }

  bool
  operator== (const next& x, const next& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      next::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (next::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    if (!(x.if_no_successor () == y.if_no_successor ()))
      return false;

    if (!(x.steps () == y.steps ()))
      return false;

    return true;
  }

  bool
  operator!= (const next& x, const next& y)
  {
    return !(x == y);
  }

  // globally
  //

  globally::
  globally ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  globally::
  globally (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  globally::
  globally (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  globally::
  globally (const globally& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  globally::
  globally (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void globally::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  globally* globally::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class globally (*this, f, c);
  }

  globally::
  ~globally ()
  {
  }

  bool
  operator== (const globally& x, const globally& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const globally& x, const globally& y)
  {
    return !(x == y);
  }

  // finally
  //

  finally::
  finally ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  finally::
  finally (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  finally::
  finally (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  finally::
  finally (const finally& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  finally::
  finally (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void finally::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  finally* finally::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class finally (*this, f, c);
  }

  finally::
  ~finally ()
  {
  }

  bool
  operator== (const finally& x, const finally& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const finally& x, const finally& y)
  {
    return !(x == y);
  }

  // until
  //

  until::
  until ()
  : ::xml_schema::type (),
    before_ (::xml_schema::flags (), this),
    reach_ (::xml_schema::flags (), this),
    strength_ (::xml_schema::flags (), this)
  {
  }

  until::
  until (const before_type& before,
         const reach_type& reach,
         const strength_type& strength)
  : ::xml_schema::type (),
    before_ (before, ::xml_schema::flags (), this),
    reach_ (reach, ::xml_schema::flags (), this),
    strength_ (strength, ::xml_schema::flags (), this)
  {
  }

  until::
  until (::std::auto_ptr< before_type >& before,
         ::std::auto_ptr< reach_type >& reach,
         const strength_type& strength)
  : ::xml_schema::type (),
    before_ (before, ::xml_schema::flags (), this),
    reach_ (reach, ::xml_schema::flags (), this),
    strength_ (strength, ::xml_schema::flags (), this)
  {
  }

  until::
  until (::std::auto_ptr< before_type >& before,
         ::std::auto_ptr< reach_type >& reach,
         ::std::auto_ptr< strength_type >& strength)
  : ::xml_schema::type (),
    before_ (before, ::xml_schema::flags (), this),
    reach_ (reach, ::xml_schema::flags (), this),
    strength_ (strength, ::xml_schema::flags (), this)
  {
  }

  until::
  until (const until& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    before_ (x.before_, f, this),
    reach_ (x.reach_, f, this),
    strength_ (x.strength_, f, this)
  {
  }

  until::
  until (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    before_ (f, this),
    reach_ (f, this),
    strength_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void until::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // before
      //
      if (n.name () == "before" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< before_type > r (
          before_traits::create (i, f, this));

        if (!before_.present ())
        {
          this->before_.set (r);
          continue;
        }
      }

      // reach
      //
      if (n.name () == "reach" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< reach_type > r (
          reach_traits::create (i, f, this));

        if (!reach_.present ())
        {
          this->reach_.set (r);
          continue;
        }
      }

      // strength
      //
      if (n.name () == "strength" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< strength_type > r (
          strength_traits::create (i, f, this));

        if (!strength_.present ())
        {
          this->strength_.set (r);
          continue;
        }
      }

      break;
    }

    if (!before_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "before",
        "http://mcc.lip6.fr/");
    }

    if (!reach_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reach",
        "http://mcc.lip6.fr/");
    }

    if (!strength_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "strength",
        "http://mcc.lip6.fr/");
    }
  }

  until* until::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class until (*this, f, c);
  }

  until::
  ~until ()
  {
  }

  bool
  operator== (const until& x, const until& y)
  {
    if (!(x.before () == y.before ()))
      return false;

    if (!(x.reach () == y.reach ()))
      return false;

    if (!(x.strength () == y.strength ()))
      return false;

    return true;
  }

  bool
  operator!= (const until& x, const until& y)
  {
    return !(x == y);
  }

  // before
  //

  before::
  before ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  before::
  before (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  before::
  before (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  before::
  before (const before& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  before::
  before (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void before::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  before* before::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class before (*this, f, c);
  }

  before::
  ~before ()
  {
  }

  bool
  operator== (const before& x, const before& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const before& x, const before& y)
  {
    return !(x == y);
  }

  // reach
  //

  reach::
  reach ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  reach::
  reach (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  reach::
  reach (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  reach::
  reach (const reach& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  reach::
  reach (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void reach::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  reach* reach::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class reach (*this, f, c);
  }

  reach::
  ~reach ()
  {
  }

  bool
  operator== (const reach& x, const reach& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const reach& x, const reach& y)
  {
    return !(x == y);
  }

  // strength
  //

  strength::
  strength (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_strength_convert ();
  }

  strength::
  strength (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_strength_convert ();
  }

  strength::
  strength (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_strength_convert ();
  }

  strength* strength::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class strength (*this, f, c);
  }

  strength::value strength::
  _xsd_strength_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_strength_literals_);
    const value* i (::std::lower_bound (
                      _xsd_strength_indexes_,
                      _xsd_strength_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_strength_indexes_ + 2 || _xsd_strength_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const strength::
  _xsd_strength_literals_[2] =
  {
    "weak",
    "strong"
  };

  const strength::value strength::
  _xsd_strength_indexes_[2] =
  {
    ::mcc::strength::strong,
    ::mcc::strength::weak
  };

  // deadlock
  //

  deadlock::
  deadlock ()
  : ::xml_schema::type ()
  {
  }

  deadlock::
  deadlock (const deadlock& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  deadlock::
  deadlock (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  deadlock::
  deadlock (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  deadlock::
  deadlock (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  deadlock* deadlock::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class deadlock (*this, f, c);
  }

  deadlock::
  ~deadlock ()
  {
  }

  bool
  operator== (const deadlock&, const deadlock&)
  {
    return true;
  }

  bool
  operator!= (const deadlock& x, const deadlock& y)
  {
    return !(x == y);
  }

  // is_live
  //

  is_live::
  is_live ()
  : ::xml_schema::type (),
    transition_ (::xml_schema::flags (), this),
    level_ (::xml_schema::flags (), this)
  {
  }

  is_live::
  is_live (const is_live& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    transition_ (x.transition_, f, this),
    level_ (x.level_, f, this)
  {
  }

  is_live::
  is_live (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    transition_ (f, this),
    level_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void is_live::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transition
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "transition",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< transition_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< transition_type > r (
            dynamic_cast< transition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->transition_.push_back (r);
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ () == "http://mcc.lip6.fr/")
      {
        ::std::auto_ptr< level_type > r (
          level_traits::create (i, f, this));

        this->level_.push_back (r);
        continue;
      }

      break;
    }
  }

  is_live* is_live::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class is_live (*this, f, c);
  }

  is_live::
  ~is_live ()
  {
  }

  bool
  operator== (const is_live& x, const is_live& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      is_live::transition_sequence a (x.transition ()), b (y.transition ());

      if (a.size () != b.size ())
        return false;

      for (is_live::transition_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    if (!(x.level () == y.level ()))
      return false;

    return true;
  }

  bool
  operator!= (const is_live& x, const is_live& y)
  {
    return !(x == y);
  }

  // level
  //

  level::
  level (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_level_convert ();
  }

  level::
  level (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_level_convert ();
  }

  level::
  level (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_level_convert ();
  }

  level* level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class level (*this, f, c);
  }

  level::value level::
  _xsd_level_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_level_literals_);
    const value* i (::std::lower_bound (
                      _xsd_level_indexes_,
                      _xsd_level_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_level_indexes_ + 5 || _xsd_level_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const level::
  _xsd_level_literals_[5] =
  {
    "l0",
    "l1",
    "l2",
    "l3",
    "l4"
  };

  const level::value level::
  _xsd_level_indexes_[5] =
  {
    ::mcc::level::l0,
    ::mcc::level::l1,
    ::mcc::level::l2,
    ::mcc::level::l3,
    ::mcc::level::l4
  };

  // is_fireable
  //

  is_fireable::
  is_fireable ()
  : ::xml_schema::type (),
    transition_ (::xml_schema::flags (), this)
  {
  }

  is_fireable::
  is_fireable (const is_fireable& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    transition_ (x.transition_, f, this)
  {
  }

  is_fireable::
  is_fireable (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    transition_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void is_fireable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transition
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "transition",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< transition_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< transition_type > r (
            dynamic_cast< transition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->transition_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  is_fireable* is_fireable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class is_fireable (*this, f, c);
  }

  is_fireable::
  ~is_fireable ()
  {
  }

  bool
  operator== (const is_fireable& x, const is_fireable& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      is_fireable::transition_sequence a (x.transition ()), b (y.transition ());

      if (a.size () != b.size ())
        return false;

      for (is_fireable::transition_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const is_fireable& x, const is_fireable& y)
  {
    return !(x == y);
  }

  // true_
  //

  true_::
  true_ ()
  : ::xml_schema::type ()
  {
  }

  true_::
  true_ (const true_& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  true_::
  true_ (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  true_::
  true_ (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  true_::
  true_ (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  true_* true_::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class true_ (*this, f, c);
  }

  true_::
  ~true_ ()
  {
  }

  bool
  operator== (const true_&, const true_&)
  {
    return true;
  }

  bool
  operator!= (const true_& x, const true_& y)
  {
    return !(x == y);
  }

  // false_
  //

  false_::
  false_ ()
  : ::xml_schema::type ()
  {
  }

  false_::
  false_ (const false_& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  false_::
  false_ (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  false_::
  false_ (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  false_::
  false_ (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  false_* false_::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class false_ (*this, f, c);
  }

  false_::
  ~false_ ()
  {
  }

  bool
  operator== (const false_&, const false_&)
  {
    return true;
  }

  bool
  operator!= (const false_& x, const false_& y)
  {
    return !(x == y);
  }

  // negation
  //

  negation::
  negation ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  negation::
  negation (const boolean_formula_type& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  negation::
  negation (::std::auto_ptr< boolean_formula_type >& boolean_formula)
  : ::xml_schema::type (),
    boolean_formula_ (boolean_formula, ::xml_schema::flags (), this)
  {
  }

  negation::
  negation (const negation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  negation::
  negation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void negation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!boolean_formula_.present ())
          {
            ::std::auto_ptr< boolean_formula_type > r (
              dynamic_cast< boolean_formula_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_formula_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!boolean_formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "boolean-formula",
        "http://mcc.lip6.fr/");
    }
  }

  negation* negation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class negation (*this, f, c);
  }

  negation::
  ~negation ()
  {
  }

  bool
  operator== (const negation& x, const negation& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      if (!cm.compare (x.boolean_formula (), y.boolean_formula ()))
        return false;
    }

    return true;
  }

  bool
  operator!= (const negation& x, const negation& y)
  {
    return !(x == y);
  }

  // conjunction
  //

  conjunction::
  conjunction ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  conjunction::
  conjunction (const conjunction& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  conjunction::
  conjunction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void conjunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  conjunction* conjunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class conjunction (*this, f, c);
  }

  conjunction::
  ~conjunction ()
  {
  }

  bool
  operator== (const conjunction& x, const conjunction& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      conjunction::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (conjunction::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const conjunction& x, const conjunction& y)
  {
    return !(x == y);
  }

  // disjunction
  //

  disjunction::
  disjunction ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  disjunction::
  disjunction (const disjunction& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  disjunction::
  disjunction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void disjunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  disjunction* disjunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class disjunction (*this, f, c);
  }

  disjunction::
  ~disjunction ()
  {
  }

  bool
  operator== (const disjunction& x, const disjunction& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      disjunction::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (disjunction::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const disjunction& x, const disjunction& y)
  {
    return !(x == y);
  }

  // exclusive_disjunction
  //

  exclusive_disjunction::
  exclusive_disjunction ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  exclusive_disjunction::
  exclusive_disjunction (const exclusive_disjunction& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  exclusive_disjunction::
  exclusive_disjunction (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void exclusive_disjunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  exclusive_disjunction* exclusive_disjunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class exclusive_disjunction (*this, f, c);
  }

  exclusive_disjunction::
  ~exclusive_disjunction ()
  {
  }

  bool
  operator== (const exclusive_disjunction& x, const exclusive_disjunction& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      exclusive_disjunction::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (exclusive_disjunction::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const exclusive_disjunction& x, const exclusive_disjunction& y)
  {
    return !(x == y);
  }

  // implication
  //

  implication::
  implication ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  implication::
  implication (const implication& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  implication::
  implication (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void implication::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  implication* implication::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class implication (*this, f, c);
  }

  implication::
  ~implication ()
  {
  }

  bool
  operator== (const implication& x, const implication& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      implication::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (implication::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const implication& x, const implication& y)
  {
    return !(x == y);
  }

  // equivalence
  //

  equivalence::
  equivalence ()
  : ::xml_schema::type (),
    boolean_formula_ (::xml_schema::flags (), this)
  {
  }

  equivalence::
  equivalence (const equivalence& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    boolean_formula_ (x.boolean_formula_, f, this)
  {
  }

  equivalence::
  equivalence (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    boolean_formula_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void equivalence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boolean-formula
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< boolean_formula_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< boolean_formula_type > r (
            dynamic_cast< boolean_formula_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->boolean_formula_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  equivalence* equivalence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class equivalence (*this, f, c);
  }

  equivalence::
  ~equivalence ()
  {
  }

  bool
  operator== (const equivalence& x, const equivalence& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      equivalence::boolean_formula_sequence a (x.boolean_formula ()), b (y.boolean_formula ());

      if (a.size () != b.size ())
        return false;

      for (equivalence::boolean_formula_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const equivalence& x, const equivalence& y)
  {
    return !(x == y);
  }

  // integer_eq
  //

  integer_eq::
  integer_eq ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_eq::
  integer_eq (const integer_eq& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_eq::
  integer_eq (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_eq::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_eq* integer_eq::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_eq (*this, f, c);
  }

  integer_eq::
  ~integer_eq ()
  {
  }

  bool
  operator== (const integer_eq& x, const integer_eq& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_eq::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_eq::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_eq& x, const integer_eq& y)
  {
    return !(x == y);
  }

  // integer_ne
  //

  integer_ne::
  integer_ne ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_ne::
  integer_ne (const integer_ne& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_ne::
  integer_ne (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_ne::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_ne* integer_ne::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_ne (*this, f, c);
  }

  integer_ne::
  ~integer_ne ()
  {
  }

  bool
  operator== (const integer_ne& x, const integer_ne& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_ne::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_ne::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_ne& x, const integer_ne& y)
  {
    return !(x == y);
  }

  // integer_lt
  //

  integer_lt::
  integer_lt ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_lt::
  integer_lt (const integer_lt& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_lt::
  integer_lt (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_lt::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_lt* integer_lt::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_lt (*this, f, c);
  }

  integer_lt::
  ~integer_lt ()
  {
  }

  bool
  operator== (const integer_lt& x, const integer_lt& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_lt::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_lt::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_lt& x, const integer_lt& y)
  {
    return !(x == y);
  }

  // integer_le
  //

  integer_le::
  integer_le ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_le::
  integer_le (const integer_le& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_le::
  integer_le (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_le::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_le* integer_le::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_le (*this, f, c);
  }

  integer_le::
  ~integer_le ()
  {
  }

  bool
  operator== (const integer_le& x, const integer_le& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_le::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_le::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_le& x, const integer_le& y)
  {
    return !(x == y);
  }

  // integer_gt
  //

  integer_gt::
  integer_gt ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_gt::
  integer_gt (const integer_gt& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_gt::
  integer_gt (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_gt::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_gt* integer_gt::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_gt (*this, f, c);
  }

  integer_gt::
  ~integer_gt ()
  {
  }

  bool
  operator== (const integer_gt& x, const integer_gt& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_gt::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_gt::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_gt& x, const integer_gt& y)
  {
    return !(x == y);
  }

  // integer_ge
  //

  integer_ge::
  integer_ge ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_ge::
  integer_ge (const integer_ge& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_ge::
  integer_ge (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_ge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_ge* integer_ge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_ge (*this, f, c);
  }

  integer_ge::
  ~integer_ge ()
  {
  }

  bool
  operator== (const integer_ge& x, const integer_ge& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_ge::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_ge::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_ge& x, const integer_ge& y)
  {
    return !(x == y);
  }

  // integer_sum
  //

  integer_sum::
  integer_sum ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_sum::
  integer_sum (const integer_sum& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_sum::
  integer_sum (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_sum::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_sum* integer_sum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_sum (*this, f, c);
  }

  integer_sum::
  ~integer_sum ()
  {
  }

  bool
  operator== (const integer_sum& x, const integer_sum& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_sum::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_sum::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_sum& x, const integer_sum& y)
  {
    return !(x == y);
  }

  // integer_product
  //

  integer_product::
  integer_product ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_product::
  integer_product (const integer_product& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_product::
  integer_product (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_product::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_product* integer_product::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_product (*this, f, c);
  }

  integer_product::
  ~integer_product ()
  {
  }

  bool
  operator== (const integer_product& x, const integer_product& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_product::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_product::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_product& x, const integer_product& y)
  {
    return !(x == y);
  }

  // integer_difference
  //

  integer_difference::
  integer_difference ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_difference::
  integer_difference (const integer_difference& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_difference::
  integer_difference (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_difference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_difference* integer_difference::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_difference (*this, f, c);
  }

  integer_difference::
  ~integer_difference ()
  {
  }

  bool
  operator== (const integer_difference& x, const integer_difference& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_difference::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_difference::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_difference& x, const integer_difference& y)
  {
    return !(x == y);
  }

  // integer_division
  //

  integer_division::
  integer_division ()
  : ::xml_schema::type (),
    integer_expression_ (::xml_schema::flags (), this)
  {
  }

  integer_division::
  integer_division (const integer_division& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    integer_expression_ (x.integer_expression_, f, this)
  {
  }

  integer_division::
  integer_division (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    integer_expression_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void integer_division::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // integer-expression
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "integer-expression",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< integer_expression_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< integer_expression_type > r (
            dynamic_cast< integer_expression_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->integer_expression_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  integer_division* integer_division::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class integer_division (*this, f, c);
  }

  integer_division::
  ~integer_division ()
  {
  }

  bool
  operator== (const integer_division& x, const integer_division& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      integer_division::integer_expression_sequence a (x.integer_expression ()), b (y.integer_expression ());

      if (a.size () != b.size ())
        return false;

      for (integer_division::integer_expression_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const integer_division& x, const integer_division& y)
  {
    return !(x == y);
  }

  // place_bound
  //

  place_bound::
  place_bound ()
  : ::xml_schema::type (),
    place_ (::xml_schema::flags (), this)
  {
  }

  place_bound::
  place_bound (const place_bound& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    place_ (x.place_, f, this)
  {
  }

  place_bound::
  place_bound (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    place_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void place_bound::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // place
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "place",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< place_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< place_type > r (
            dynamic_cast< place_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->place_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  place_bound* place_bound::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class place_bound (*this, f, c);
  }

  place_bound::
  ~place_bound ()
  {
  }

  bool
  operator== (const place_bound& x, const place_bound& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      place_bound::place_sequence a (x.place ()), b (y.place ());

      if (a.size () != b.size ())
        return false;

      for (place_bound::place_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const place_bound& x, const place_bound& y)
  {
    return !(x == y);
  }

  // tokens_count
  //

  tokens_count::
  tokens_count ()
  : ::xml_schema::type (),
    place_ (::xml_schema::flags (), this)
  {
  }

  tokens_count::
  tokens_count (const tokens_count& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    place_ (x.place_, f, this)
  {
  }

  tokens_count::
  tokens_count (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    place_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void tokens_count::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // place
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "place",
            "http://mcc.lip6.fr/",
            &::xsd::cxx::tree::factory_impl< place_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< place_type > r (
            dynamic_cast< place_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->place_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  tokens_count* tokens_count::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tokens_count (*this, f, c);
  }

  tokens_count::
  ~tokens_count ()
  {
  }

  bool
  operator== (const tokens_count& x, const tokens_count& y)
  {
    {
      ::xsd::cxx::tree::comparison_map< char >& cm (
        ::xsd::cxx::tree::comparison_map_instance< 0, char > ());

      tokens_count::place_sequence a (x.place ()), b (y.place ());

      if (a.size () != b.size ())
        return false;

      for (tokens_count::place_const_iterator
           ai (a.begin ()), bi (b.begin ()), ae (a.end ()), be (b.end ());
           ai != ae; ++ai, ++bi)
      {
        if (!cm.compare (*ai, *bi))
          return false;
      }
    }

    return true;
  }

  bool
  operator!= (const tokens_count& x, const tokens_count& y)
  {
    return !(x == y);
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mcc
{
  ::std::ostream&
  operator<< (::std::ostream& o, const formula& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.boolean_formula ())
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *i.boolean_formula ());
      }
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      if (i.integer_formula ())
      {
        o << ::std::endl << "integer-formula: ";
        om.insert (o, *i.integer_formula ());
      }
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, formula >
  _xsd_formula_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const property_set& i)
  {
    for (property_set::property_const_iterator
         b (i.property ().begin ()), e (i.property ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "property: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const property& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "id: ";
      om.insert (o, i.id ());
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "description: ";
      om.insert (o, i.description ());
    }

    o << ::std::endl << "tags: " << i.tags ();
    if (i.expected_result ())
    {
      o << ::std::endl << "expected-result: " << *i.expected_result ();
    }

    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "formula: ";
      om.insert (o, i.formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const tags& i)
  {
    o << ::std::endl << "is-structural: " << i.is_structural ();
    o << ::std::endl << "is-reachability: " << i.is_reachability ();
    o << ::std::endl << "is-ctl: " << i.is_ctl ();
    o << ::std::endl << "is-ltl: " << i.is_ltl ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const expected_result& i)
  {
    o << ::std::endl << "value: " << i.value ();
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "explanation: ";
      om.insert (o, i.explanation ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const value& i)
  {
    return o << static_cast< const ::xml_schema::string& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const invariant& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const impossibility& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const possibility& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const all_paths& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const exists_path& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const next& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (next::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    for (next::if_no_successor_const_iterator
         b (i.if_no_successor ().begin ()), e (i.if_no_successor ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "if-no-successor: " << *b;
    }

    for (next::steps_const_iterator
         b (i.steps ().begin ()), e (i.steps ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "steps: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const globally& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const finally& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const until& i)
  {
    o << ::std::endl << "before: " << i.before ();
    o << ::std::endl << "reach: " << i.reach ();
    o << ::std::endl << "strength: " << i.strength ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const before& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const reach& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, strength::value i)
  {
    return o << strength::_xsd_strength_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const strength& i)
  {
    return o << static_cast< const ::xml_schema::token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const deadlock&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const is_live& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (is_live::transition_const_iterator
           b (i.transition ().begin ()), e (i.transition ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "transition: ";
        om.insert (o, *b);
      }
    }

    for (is_live::level_const_iterator
         b (i.level ().begin ()), e (i.level ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "level: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, level::value i)
  {
    return o << level::_xsd_level_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const level& i)
  {
    return o << static_cast< const ::xml_schema::token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const is_fireable& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (is_fireable::transition_const_iterator
           b (i.transition ().begin ()), e (i.transition ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "transition: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const true_&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const false_&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const negation& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      o << ::std::endl << "boolean-formula: ";
      om.insert (o, i.boolean_formula ());
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const conjunction& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (conjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const disjunction& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (disjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const exclusive_disjunction& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (exclusive_disjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const implication& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (implication::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const equivalence& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (equivalence::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), e (i.boolean_formula ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "boolean-formula: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_eq& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_eq::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_ne& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_ne::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_lt& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_lt::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_le& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_le::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_gt& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_gt::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_ge& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_ge::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_sum& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_sum::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_product& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_product::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_difference& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_difference::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const integer_division& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (integer_division::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), e (i.integer_expression ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "integer-expression: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const place_bound& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (place_bound::place_const_iterator
           b (i.place ().begin ()), e (i.place ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "place: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const tokens_count& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (tokens_count::place_const_iterator
           b (i.place ().begin ()), e (i.place ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "place: ";
        om.insert (o, *b);
      }
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mcc
{
  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mcc::property_set_ (isrc, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mcc::property_set_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::mcc::property_set_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mcc::property_set_ (isrc, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mcc::property_set_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::mcc::property_set_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::mcc::property_set > r (
      ::mcc::property_set_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::mcc::property_set > r (
        ::mcc::property_set_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "property-set" &&
        n.namespace_ () == "http://mcc.lip6.fr/")
    {
      ::std::auto_ptr< ::mcc::property_set > r (
        ::xsd::cxx::tree::traits< ::mcc::property_set, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "property-set",
      "http://mcc.lip6.fr/");
  }

  ::std::auto_ptr< ::mcc::property_set >
  property_set_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "property-set" &&
        n.namespace_ () == "http://mcc.lip6.fr/")
    {
      ::std::auto_ptr< ::mcc::property_set > r (
        ::xsd::cxx::tree::traits< ::mcc::property_set, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "property-set",
      "http://mcc.lip6.fr/");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mcc
{
  void
  property_set_ (::std::ostream& o,
                 const ::mcc::property_set& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  property_set_ (::std::ostream& o,
                 const ::mcc::property_set& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  property_set_ (::std::ostream& o,
                 const ::mcc::property_set& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  property_set_ (::xercesc::XMLFormatTarget& t,
                 const ::mcc::property_set& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  property_set_ (::xercesc::XMLFormatTarget& t,
                 const ::mcc::property_set& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  property_set_ (::xercesc::XMLFormatTarget& t,
                 const ::mcc::property_set& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::mcc::property_set_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  property_set_ (::xercesc::DOMDocument& d,
                 const ::mcc::property_set& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "property-set" &&
        n.namespace_ () == "http://mcc.lip6.fr/")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "property-set",
        "http://mcc.lip6.fr/");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  property_set_ (const ::mcc::property_set& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "property-set",
        "http://mcc.lip6.fr/",
        m, f));

    ::mcc::property_set_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const formula& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.boolean_formula ())
      {
        const formula::boolean_formula_type& x (*i.boolean_formula ());
        if (typeid (formula::boolean_formula_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, x);
      }
    }

    // integer-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.integer_formula ())
      {
        const formula::integer_formula_type& x (*i.integer_formula ());
        if (typeid (formula::integer_formula_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-formula",
              "http://mcc.lip6.fr/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "integer-formula",
            "http://mcc.lip6.fr/",
            true, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, formula >
  _xsd_formula_type_serializer_init (
    "formula",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::invariant >
  _xsd_invariant__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "invariant",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::impossibility >
  _xsd_impossibility__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "impossibility",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::possibility >
  _xsd_possibility__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "possibility",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::all_paths >
  _xsd_all_paths__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "all-paths",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::exists_path >
  _xsd_exists_path__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "exists-path",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::next >
  _xsd_next__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "next",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::globally >
  _xsd_globally__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "globally",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::finally >
  _xsd_finally__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "finally",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::until >
  _xsd_until__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "until",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::deadlock >
  _xsd_deadlock__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "deadlock",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::is_live >
  _xsd_is_live__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "is-live",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::is_fireable >
  _xsd_is_fireable__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "is-fireable",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::true_ >
  _xsd_true___element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "true",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::false_ >
  _xsd_false___element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "false",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::negation >
  _xsd_negation__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "negation",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::conjunction >
  _xsd_conjunction__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "conjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::disjunction >
  _xsd_disjunction__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "disjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::exclusive_disjunction >
  _xsd_exclusive_disjunction__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "exclusive-disjunction",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::implication >
  _xsd_implication__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "implication",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::equivalence >
  _xsd_equivalence__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "equivalence",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_eq >
  _xsd_integer_eq__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-eq",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_ne >
  _xsd_integer_ne__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-ne",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_lt >
  _xsd_integer_lt__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-lt",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_le >
  _xsd_integer_le__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-le",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_gt >
  _xsd_integer_gt__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-gt",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_ge >
  _xsd_integer_ge__element_serializer_init (
    "boolean-formula",
    "http://mcc.lip6.fr/",
    "integer-ge",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xml_schema::type >
  _xsd_integer_expression_element_serializer_init (
    "integer-formula",
    "http://mcc.lip6.fr/",
    "integer-expression",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xml_schema::integer >
  _xsd_integer_constant_element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-constant",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_sum >
  _xsd_integer_sum__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-sum",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_product >
  _xsd_integer_product__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-product",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_difference >
  _xsd_integer_difference__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-difference",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::integer_division >
  _xsd_integer_division__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "integer-division",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::place_bound >
  _xsd_place_bound__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "place-bound",
    "http://mcc.lip6.fr/");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::mcc::tokens_count >
  _xsd_tokens_count__element_serializer_init (
    "integer-expression",
    "http://mcc.lip6.fr/",
    "tokens-count",
    "http://mcc.lip6.fr/");


  void
  operator<< (::xercesc::DOMElement& e, const property_set& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // property
    //
    for (property_set::property_const_iterator
         b (i.property ().begin ()), n (i.property ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "property",
          "http://mcc.lip6.fr/",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const property& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // id
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const property::id_type& x (i.id ());
      if (typeid (property::id_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "id",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }

    // description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const property::description_type& x (i.description ());
      if (typeid (property::description_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "description",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "description",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }

    // tags
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tags",
          "http://mcc.lip6.fr/",
          e));

      s << i.tags ();
    }

    // expected-result
    //
    if (i.expected_result ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expected-result",
          "http://mcc.lip6.fr/",
          e));

      s << *i.expected_result ();
    }

    // formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const property::formula_type& x (i.formula ());
      if (typeid (property::formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const tags& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // is-structural
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is-structural",
          "http://mcc.lip6.fr/",
          e));

      s << i.is_structural ();
    }

    // is-reachability
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is-reachability",
          "http://mcc.lip6.fr/",
          e));

      s << i.is_reachability ();
    }

    // is-ctl
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is-ctl",
          "http://mcc.lip6.fr/",
          e));

      s << i.is_ctl ();
    }

    // is-ltl
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is-ltl",
          "http://mcc.lip6.fr/",
          e));

      s << i.is_ltl ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const expected_result& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://mcc.lip6.fr/",
          e));

      s << i.value ();
    }

    // explanation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const expected_result::explanation_type& x (i.explanation ());
      if (typeid (expected_result::explanation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "explanation",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "explanation",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const value& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const value& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const value& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const invariant& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const invariant::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (invariant::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const impossibility& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const impossibility::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (impossibility::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const possibility& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const possibility::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (possibility::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const all_paths& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const all_paths::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (all_paths::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const exists_path& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const exists_path::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (exists_path::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const next& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (next::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (next::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }

    // if-no-successor
    //
    for (next::if_no_successor_const_iterator
         b (i.if_no_successor ().begin ()), n (i.if_no_successor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "if-no-successor",
          "http://mcc.lip6.fr/",
          e));

      s << *b;
    }

    // steps
    //
    for (next::steps_const_iterator
         b (i.steps ().begin ()), n (i.steps ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "steps",
          "http://mcc.lip6.fr/",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const globally& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const globally::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (globally::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const finally& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const finally::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (finally::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const until& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // before
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "before",
          "http://mcc.lip6.fr/",
          e));

      s << i.before ();
    }

    // reach
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reach",
          "http://mcc.lip6.fr/",
          e));

      s << i.reach ();
    }

    // strength
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "strength",
          "http://mcc.lip6.fr/",
          e));

      s << i.strength ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const before& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const before::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (before::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const reach& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const reach::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (reach::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const strength& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const strength& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const strength& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const deadlock& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const deadlock&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const deadlock&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const is_live& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // transition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (is_live::transition_const_iterator
           b (i.transition ().begin ()), n (i.transition ().end ());
           b != n; ++b)
      {
        if (typeid (is_live::transition_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "transition",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "transition",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }

    // level
    //
    for (is_live::level_const_iterator
         b (i.level ().begin ()), n (i.level ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "level",
          "http://mcc.lip6.fr/",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const level& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const level& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const level& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const is_fireable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // transition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (is_fireable::transition_const_iterator
           b (i.transition ().begin ()), n (i.transition ().end ());
           b != n; ++b)
      {
        if (typeid (is_fireable::transition_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "transition",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "transition",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const true_& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const true_&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const true_&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const false_& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const false_&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const false_&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const negation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const negation::boolean_formula_type& x (i.boolean_formula ());
      if (typeid (negation::boolean_formula_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "boolean-formula",
          "http://mcc.lip6.fr/",
          true, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const conjunction& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (conjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (conjunction::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const disjunction& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (disjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (disjunction::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const exclusive_disjunction& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (exclusive_disjunction::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (exclusive_disjunction::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const implication& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (implication::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (implication::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const equivalence& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // boolean-formula
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (equivalence::boolean_formula_const_iterator
           b (i.boolean_formula ().begin ()), n (i.boolean_formula ().end ());
           b != n; ++b)
      {
        if (typeid (equivalence::boolean_formula_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "boolean-formula",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "boolean-formula",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_eq& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_eq::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_eq::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_ne& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_ne::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_ne::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_lt& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_lt::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_lt::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_le& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_le::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_le::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_gt& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_gt::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_gt::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_ge& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_ge::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_ge::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_sum& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_sum::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_sum::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_product& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_product::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_product::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_difference& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_difference::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_difference::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const integer_division& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // integer-expression
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (integer_division::integer_expression_const_iterator
           b (i.integer_expression ().begin ()), n (i.integer_expression ().end ());
           b != n; ++b)
      {
        if (typeid (integer_division::integer_expression_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "integer-expression",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "integer-expression",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const place_bound& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // place
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (place_bound::place_const_iterator
           b (i.place ().begin ()), n (i.place ().end ());
           b != n; ++b)
      {
        if (typeid (place_bound::place_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "place",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "place",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const tokens_count& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // place
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (tokens_count::place_const_iterator
           b (i.place ().begin ()), n (i.place ().end ());
           b != n; ++b)
      {
        if (typeid (tokens_count::place_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "place",
              "http://mcc.lip6.fr/",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "place",
            "http://mcc.lip6.fr/",
            true, true, e, *b);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

